


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > In</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">edu.princeton.cs.algs4</a>
</div>

<h1>Coverage Summary for Class: In (edu.princeton.cs.algs4)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">In</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/256)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/******************************************************************************
&nbsp; *  Compilation:  javac In.java
&nbsp; *  Execution:    java In   (basic test --- see source for required files)
&nbsp; *  Dependencies: none
&nbsp; *
&nbsp; *  Reads in data of various types from standard input, files, and URLs.
&nbsp; *
&nbsp; ******************************************************************************/
&nbsp;
&nbsp;package edu.princeton.cs.algs4;
&nbsp;
&nbsp;import java.io.BufferedInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.net.URL;
&nbsp;import java.net.Socket;
&nbsp;// import java.net.HttpURLConnection;
&nbsp;import java.net.URLConnection;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.InputMismatchException;
&nbsp;import java.util.Locale;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Scanner;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;/**
&nbsp; *  &lt;i&gt;Input&lt;/i&gt;. This class provides methods for reading strings
&nbsp; *  and numbers from standard input, file input, URLs, and sockets. 
&nbsp; *  &lt;p&gt;
&nbsp; *  The Locale used is: language = English, country = US. This is consistent
&nbsp; *  with the formatting conventions with Java floating-point literals,
&nbsp; *  command-line arguments (via {@link Double#parseDouble(String)})
&nbsp; *  and standard output. 
&nbsp; *  &lt;p&gt;
&nbsp; *  For additional documentation, see 
&nbsp; *  &lt;a href=&quot;https://introcs.cs.princeton.edu/31datatype&quot;&gt;Section 3.1&lt;/a&gt; of
&nbsp; *  &lt;i&gt;Computer Science: An Interdisciplinary Approach&lt;/i&gt; 
&nbsp; *  by Robert Sedgewick and Kevin Wayne.
&nbsp; *  &lt;p&gt;
&nbsp; *  Like {@link Scanner}, reading a token also consumes preceding Java
&nbsp; *  whitespace, reading a full line consumes
&nbsp; *  the following end-of-line delimeter, while reading a character consumes
&nbsp; *  nothing extra. 
&nbsp; *  &lt;p&gt;
&nbsp; *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines
&nbsp; *  consist of \n, \r, \r\n, and Unicode hex code points 0x2028, 0x2029, 0x0085;
&nbsp; *  see &lt;a href=&quot;http://www.docjar.com/html/api/java/util/Scanner.java.html&quot;&gt;
&nbsp; *  Scanner.java&lt;/a&gt; (NB: Java 6u23 and earlier uses only \r, \r, \r\n).
&nbsp; *
&nbsp; *  @author David Pritchard
&nbsp; *  @author Robert Sedgewick
&nbsp; *  @author Kevin Wayne
&nbsp; */
&nbsp;public final class In {
&nbsp;    
&nbsp;    ///// begin: section (1 of 2) of code duplicated from In to StdIn.
&nbsp;    
&nbsp;    // assume Unicode UTF-8 encoding
&nbsp;    private static final String CHARSET_NAME = &quot;UTF-8&quot;;
&nbsp;
&nbsp;    // assume language = English, country = US for consistency with System.out.
<b class="nc">&nbsp;    private static final Locale LOCALE = Locale.US;</b>
&nbsp;
&nbsp;    // the default token separator; we maintain the invariant that this value 
&nbsp;    // is held by the scanner&#39;s delimiter between calls
<b class="nc">&nbsp;    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(&quot;\\p{javaWhitespace}+&quot;);</b>
&nbsp;
&nbsp;    // makes whitespace characters significant 
<b class="nc">&nbsp;    private static final Pattern EMPTY_PATTERN = Pattern.compile(&quot;&quot;);</b>
&nbsp;
&nbsp;    // used to read the entire input. source:
&nbsp;    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html
<b class="nc">&nbsp;    private static final Pattern EVERYTHING_PATTERN = Pattern.compile(&quot;\\A&quot;);</b>
&nbsp;
&nbsp;    //// end: section (1 of 2) of code duplicated from In to StdIn.
&nbsp;
&nbsp;    private Scanner scanner;
&nbsp;
&nbsp;   /**
&nbsp;     * Initializes an input stream from standard input.
&nbsp;     */
<b class="nc">&nbsp;    public In() {</b>
<b class="nc">&nbsp;        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);</b>
<b class="nc">&nbsp;        scanner.useLocale(LOCALE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;   /**
&nbsp;     * Initializes an input stream from a socket.
&nbsp;     *
&nbsp;     * @param  socket the socket
&nbsp;     * @throws IllegalArgumentException if cannot open {@code socket}
&nbsp;     * @throws IllegalArgumentException if {@code socket} is {@code null}
&nbsp;     */
<b class="nc">&nbsp;    public In(Socket socket) {</b>
<b class="nc">&nbsp;        if (socket == null) throw new IllegalArgumentException(&quot;socket argument is null&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            InputStream is = socket.getInputStream();</b>
<b class="nc">&nbsp;            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);</b>
<b class="nc">&nbsp;            scanner.useLocale(LOCALE);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IOException ioe) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not open &quot; + socket, ioe);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;   /**
&nbsp;     * Initializes an input stream from a URL.
&nbsp;     *
&nbsp;     * @param  url the URL
&nbsp;     * @throws IllegalArgumentException if cannot open {@code url}
&nbsp;     * @throws IllegalArgumentException if {@code url} is {@code null}
&nbsp;     */
<b class="nc">&nbsp;    public In(URL url) {</b>
<b class="nc">&nbsp;        if (url == null) throw new IllegalArgumentException(&quot;url argument is null&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            URLConnection site = url.openConnection();</b>
<b class="nc">&nbsp;            InputStream is     = site.getInputStream();</b>
<b class="nc">&nbsp;            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);</b>
<b class="nc">&nbsp;            scanner.useLocale(LOCALE);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IOException ioe) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not open &quot; + url, ioe);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;   /**
&nbsp;     * Initializes an input stream from a file.
&nbsp;     *
&nbsp;     * @param  file the file
&nbsp;     * @throws IllegalArgumentException if cannot open {@code file}
&nbsp;     * @throws IllegalArgumentException if {@code file} is {@code null}
&nbsp;     */
<b class="nc">&nbsp;    public In(File file) {</b>
<b class="nc">&nbsp;        if (file == null) throw new IllegalArgumentException(&quot;file argument is null&quot;);</b>
&nbsp;        try {
&nbsp;            // for consistency with StdIn, wrap with BufferedInputStream instead of use
&nbsp;            // file as argument to Scanner
<b class="nc">&nbsp;            FileInputStream fis = new FileInputStream(file);</b>
<b class="nc">&nbsp;            scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);</b>
<b class="nc">&nbsp;            scanner.useLocale(LOCALE);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IOException ioe) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not open &quot; + file, ioe);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;   /**
&nbsp;     * Initializes an input stream from a filename or web page name.
&nbsp;     *
&nbsp;     * @param  name the filename or web page name
&nbsp;     * @throws IllegalArgumentException if cannot open {@code name} as
&nbsp;     *         a file or URL
&nbsp;     * @throws IllegalArgumentException if {@code name} is {@code null}
&nbsp;     */
<b class="nc">&nbsp;    public In(String name) {</b>
<b class="nc">&nbsp;        if (name == null) throw new IllegalArgumentException(&quot;argument is null&quot;);</b>
<b class="nc">&nbsp;        if (name.length() == 0) throw new IllegalArgumentException(&quot;argument is the empty string&quot;);</b>
&nbsp;        try {
&nbsp;            // first try to read file from local file system
<b class="nc">&nbsp;            File file = new File(name);</b>
<b class="nc">&nbsp;            if (file.exists()) {</b>
&nbsp;                // for consistency with StdIn, wrap with BufferedInputStream instead of use
&nbsp;                // file as argument to Scanner
<b class="nc">&nbsp;                FileInputStream fis = new FileInputStream(file);</b>
<b class="nc">&nbsp;                scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);</b>
<b class="nc">&nbsp;                scanner.useLocale(LOCALE);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // resource relative to .class file
<b class="nc">&nbsp;            URL url = getClass().getResource(name);</b>
&nbsp;
&nbsp;            // resource relative to classloader root
<b class="nc">&nbsp;            if (url == null) {</b>
<b class="nc">&nbsp;                url = getClass().getClassLoader().getResource(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            // or URL from web
<b class="nc">&nbsp;            if (url == null) {</b>
<b class="nc">&nbsp;                url = new URL(name);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            URLConnection site = url.openConnection();</b>
&nbsp;
&nbsp;            // in order to set User-Agent, replace above line with these two
&nbsp;            // HttpURLConnection site = (HttpURLConnection) url.openConnection();
&nbsp;            // site.addRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.76&quot;);
&nbsp;
<b class="nc">&nbsp;            InputStream is     = site.getInputStream();</b>
<b class="nc">&nbsp;            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);</b>
<b class="nc">&nbsp;            scanner.useLocale(LOCALE);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IOException ioe) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not open &quot; + name, ioe);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes an input stream from a given {@link Scanner} source; use with 
&nbsp;     * {@code new Scanner(String)} to read from a string.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that this does not create a defensive copy, so the
&nbsp;     * scanner will be mutated as you read on. 
&nbsp;     *
&nbsp;     * @param  scanner the scanner
&nbsp;     * @throws IllegalArgumentException if {@code scanner} is {@code null}
&nbsp;     */
<b class="nc">&nbsp;    public In(Scanner scanner) {</b>
<b class="nc">&nbsp;        if (scanner == null) throw new IllegalArgumentException(&quot;scanner argument is null&quot;);</b>
<b class="nc">&nbsp;        this.scanner = scanner;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this input stream exists.
&nbsp;     *
&nbsp;     * @return {@code true} if this input stream exists; {@code false} otherwise
&nbsp;     */
&nbsp;    public boolean exists()  {
<b class="nc">&nbsp;        return scanner != null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    ////  begin: section (2 of 2) of code duplicated from In to StdIn,
&nbsp;    ////  with all methods changed from &quot;public&quot; to &quot;public static&quot;.
&nbsp;
&nbsp;   /**
&nbsp;     * Returns true if input stream is empty (except possibly whitespace).
&nbsp;     * Use this to know whether the next call to {@link #readString()}, 
&nbsp;     * {@link #readDouble()}, etc will succeed.
&nbsp;     *
&nbsp;     * @return {@code true} if this input stream is empty (except possibly whitespace);
&nbsp;     *         {@code false} otherwise
&nbsp;     */
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        return !scanner.hasNext();</b>
&nbsp;    }
&nbsp;
&nbsp;   /** 
&nbsp;     * Returns true if this input stream has a next line.
&nbsp;     * Use this method to know whether the
&nbsp;     * next call to {@link #readLine()} will succeed.
&nbsp;     * This method is functionally equivalent to {@link #hasNextChar()}.
&nbsp;     *
&nbsp;     * @return {@code true} if this input stream has more input (including whitespace);
&nbsp;     *         {@code false} otherwise
&nbsp;     */
&nbsp;    public boolean hasNextLine() {
<b class="nc">&nbsp;        return scanner.hasNextLine();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this input stream has more input (including whitespace).
&nbsp;     * Use this method to know whether the next call to {@link #readChar()} will succeed.
&nbsp;     * This method is functionally equivalent to {@link #hasNextLine()}.
&nbsp;     * 
&nbsp;     * @return {@code true} if this input stream has more input (including whitespace);
&nbsp;     *         {@code false} otherwise   
&nbsp;     */
&nbsp;    public boolean hasNextChar() {
<b class="nc">&nbsp;        scanner.useDelimiter(EMPTY_PATTERN);</b>
<b class="nc">&nbsp;        boolean result = scanner.hasNext();</b>
<b class="nc">&nbsp;        scanner.useDelimiter(WHITESPACE_PATTERN);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;   /**
&nbsp;     * Reads and returns the next line in this input stream.
&nbsp;     *
&nbsp;     * @return the next line in this input stream; {@code null} if no such line
&nbsp;     */
&nbsp;    public String readLine() {
&nbsp;        String line;
&nbsp;        try {
<b class="nc">&nbsp;            line = scanner.nextLine();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            line = null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return line;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads and returns the next character in this input stream.
&nbsp;     *
&nbsp;     * @return the next {@code char} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     */
&nbsp;    public char readChar() {
<b class="nc">&nbsp;        scanner.useDelimiter(EMPTY_PATTERN);</b>
&nbsp;        try {
<b class="nc">&nbsp;            String ch = scanner.next();</b>
<b class="nc">&nbsp;            assert ch.length() == 1 : &quot;Internal (Std)In.readChar() error!&quot;</b>
&nbsp;                + &quot; Please contact the authors.&quot;;
<b class="nc">&nbsp;            scanner.useDelimiter(WHITESPACE_PATTERN);</b>
<b class="nc">&nbsp;            return ch.charAt(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attempts to read a &#39;char&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }  
&nbsp;
&nbsp;
&nbsp;   /**
&nbsp;     * Reads and returns the remainder of this input stream, as a string.
&nbsp;     *
&nbsp;     * @return the remainder of this input stream, as a string
&nbsp;     */
&nbsp;    public String readAll() {
<b class="nc">&nbsp;        if (!scanner.hasNextLine())</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();</b>
&nbsp;        // not that important to reset delimeter, since now scanner is empty
<b class="nc">&nbsp;        scanner.useDelimiter(WHITESPACE_PATTERN); // but let&#39;s do it anyway</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream and returns it as a {@code String}.
&nbsp;     *
&nbsp;     * @return the next {@code String} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     */
&nbsp;    public String readString() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.next();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attempts to read a &#39;String&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code int},
&nbsp;     * and returns the {@code int}.
&nbsp;     *
&nbsp;     * @return the next {@code int} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
&nbsp;     */
&nbsp;    public int readInt() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextInt();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read an &#39;int&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read an &#39;int&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code double},
&nbsp;     * and returns the {@code double}.
&nbsp;     *
&nbsp;     * @return the next {@code double} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
&nbsp;     */
&nbsp;    public double readDouble() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextDouble();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;double&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read a &#39;double&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code float},
&nbsp;     * and returns the {@code float}.
&nbsp;     *
&nbsp;     * @return the next {@code float} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
&nbsp;     */
&nbsp;    public float readFloat() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextFloat();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;float&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read a &#39;float&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code long},
&nbsp;     * and returns the {@code long}.
&nbsp;     *
&nbsp;     * @return the next {@code long} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
&nbsp;     */
&nbsp;    public long readLong() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextLong();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;long&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read a &#39;long&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code short},
&nbsp;     * and returns the {@code short}.
&nbsp;     *
&nbsp;     * @return the next {@code short} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
&nbsp;     */
&nbsp;    public short readShort() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextShort();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;short&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read a &#39;short&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code byte},
&nbsp;     * and returns the {@code byte}.
&nbsp;     * &lt;p&gt;
&nbsp;     * To read binary data, use {@link BinaryIn}.
&nbsp;     *
&nbsp;     * @return the next {@code byte} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
&nbsp;     */
&nbsp;    public byte readByte() {
&nbsp;        try {
<b class="nc">&nbsp;            return scanner.nextByte();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (InputMismatchException e) {</b>
<b class="nc">&nbsp;            String token = scanner.next();</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;byte&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attemps to read a &#39;byte&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads the next token from this input stream, parses it as a {@code boolean}
&nbsp;     * (interpreting either {@code &quot;true&quot;} or {@code &quot;1&quot;} as {@code true},
&nbsp;     * and either {@code &quot;false&quot;} or {@code &quot;0&quot;} as {@code false}).
&nbsp;     *
&nbsp;     * @return the next {@code boolean} in this input stream
&nbsp;     * @throws NoSuchElementException if the input stream is empty
&nbsp;     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}
&nbsp;     */
&nbsp;    public boolean readBoolean() {
&nbsp;        try {
<b class="nc">&nbsp;            String token = readString();</b>
<b class="nc">&nbsp;            if (&quot;true&quot;.equalsIgnoreCase(token))  return true;</b>
<b class="nc">&nbsp;            if (&quot;false&quot;.equalsIgnoreCase(token)) return false;</b>
<b class="nc">&nbsp;            if (&quot;1&quot;.equals(token))               return true;</b>
<b class="nc">&nbsp;            if (&quot;0&quot;.equals(token))               return false;</b>
<b class="nc">&nbsp;            throw new InputMismatchException(&quot;attempts to read a &#39;boolean&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but the next token is \&quot;&quot; + token + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;        catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            throw new NoSuchElementException(&quot;attempts to read a &#39;boolean&#39; value from the input stream, &quot;</b>
&nbsp;                                           + &quot;but no more tokens are available&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all remaining tokens from this input stream and returns them as
&nbsp;     * an array of strings.
&nbsp;     *
&nbsp;     * @return all remaining tokens in this input stream, as an array of strings
&nbsp;     */
&nbsp;    public String[] readAllStrings() {
&nbsp;        // we could use readAll.trim().split(), but that&#39;s not consistent
&nbsp;        // since trim() uses characters 0x00..0x20 as whitespace
<b class="nc">&nbsp;        String[] tokens = WHITESPACE_PATTERN.split(readAll());</b>
<b class="nc">&nbsp;        if (tokens.length == 0 || tokens[0].length() &gt; 0)</b>
<b class="nc">&nbsp;            return tokens;</b>
<b class="nc">&nbsp;        String[] decapitokens = new String[tokens.length-1];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; tokens.length-1; i++)</b>
<b class="nc">&nbsp;            decapitokens[i] = tokens[i+1];</b>
<b class="nc">&nbsp;        return decapitokens;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all remaining lines from this input stream and returns them as
&nbsp;     * an array of strings.
&nbsp;     *
&nbsp;     * @return all remaining lines in this input stream, as an array of strings
&nbsp;     */
&nbsp;    public String[] readAllLines() {
<b class="nc">&nbsp;        ArrayList&lt;String&gt; lines = new ArrayList&lt;String&gt;();</b>
<b class="nc">&nbsp;        while (hasNextLine()) {</b>
<b class="nc">&nbsp;            lines.add(readLine());</b>
&nbsp;        }
<b class="nc">&nbsp;        return lines.toArray(new String[lines.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all remaining tokens from this input stream, parses them as integers,
&nbsp;     * and returns them as an array of integers.
&nbsp;     *
&nbsp;     * @return all remaining lines in this input stream, as an array of integers
&nbsp;     */
&nbsp;    public int[] readAllInts() {
<b class="nc">&nbsp;        String[] fields = readAllStrings();</b>
<b class="nc">&nbsp;        int[] vals = new int[fields.length];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; fields.length; i++)</b>
<b class="nc">&nbsp;            vals[i] = Integer.parseInt(fields[i]);</b>
<b class="nc">&nbsp;        return vals;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all remaining tokens from this input stream, parses them as longs,
&nbsp;     * and returns them as an array of longs.
&nbsp;     *
&nbsp;     * @return all remaining lines in this input stream, as an array of longs
&nbsp;     */
&nbsp;    public long[] readAllLongs() {
<b class="nc">&nbsp;        String[] fields = readAllStrings();</b>
<b class="nc">&nbsp;        long[] vals = new long[fields.length];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; fields.length; i++)</b>
<b class="nc">&nbsp;            vals[i] = Long.parseLong(fields[i]);</b>
<b class="nc">&nbsp;        return vals;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all remaining tokens from this input stream, parses them as doubles,
&nbsp;     * and returns them as an array of doubles.
&nbsp;     *
&nbsp;     * @return all remaining lines in this input stream, as an array of doubles
&nbsp;     */
&nbsp;    public double[] readAllDoubles() {
<b class="nc">&nbsp;        String[] fields = readAllStrings();</b>
<b class="nc">&nbsp;        double[] vals = new double[fields.length];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; fields.length; i++)</b>
<b class="nc">&nbsp;            vals[i] = Double.parseDouble(fields[i]);</b>
<b class="nc">&nbsp;        return vals;</b>
&nbsp;    }
&nbsp;    
&nbsp;    ///// end: section (2 of 2) of code duplicated from In to StdIn */
&nbsp;
&nbsp;   /**
&nbsp;     * Closes this input stream.
&nbsp;     */
&nbsp;    public void close() {
<b class="nc">&nbsp;        scanner.close();  </b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all integers from a file and returns them as
&nbsp;     * an array of integers.
&nbsp;     *
&nbsp;     * @param      filename the name of the file
&nbsp;     * @return     the integers in the file
&nbsp;     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllInts()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static int[] readInts(String filename) {
<b class="nc">&nbsp;        return new In(filename).readAllInts();</b>
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads all doubles from a file and returns them as
&nbsp;     * an array of doubles.
&nbsp;     *
&nbsp;     * @param      filename the name of the file
&nbsp;     * @return     the doubles in the file
&nbsp;     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllDoubles()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static double[] readDoubles(String filename) {
<b class="nc">&nbsp;        return new In(filename).readAllDoubles();</b>
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads all strings from a file and returns them as
&nbsp;     * an array of strings.
&nbsp;     *
&nbsp;     * @param      filename the name of the file
&nbsp;     * @return     the strings in the file
&nbsp;     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllStrings()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static String[] readStrings(String filename) {
<b class="nc">&nbsp;        return new In(filename).readAllStrings();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads all integers from standard input and returns them
&nbsp;     * an array of integers.
&nbsp;     *
&nbsp;     * @return     the integers on standard input
&nbsp;     * @deprecated Replaced by {@link StdIn#readAllInts()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static int[] readInts() {
<b class="nc">&nbsp;        return new In().readAllInts();</b>
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads all doubles from standard input and returns them as
&nbsp;     * an array of doubles.
&nbsp;     *
&nbsp;     * @return     the doubles on standard input
&nbsp;     * @deprecated Replaced by {@link StdIn#readAllDoubles()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static double[] readDoubles() {
<b class="nc">&nbsp;        return new In().readAllDoubles();</b>
&nbsp;    }
&nbsp;
&nbsp;   /**
&nbsp;     * Reads all strings from standard input and returns them as
&nbsp;     *  an array of strings.
&nbsp;     *
&nbsp;     * @return     the strings on standard input
&nbsp;     * @deprecated Replaced by {@link StdIn#readAllStrings()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static String[] readStrings() {
<b class="nc">&nbsp;        return new In().readAllStrings();</b>
&nbsp;    }
&nbsp;    
&nbsp;   /**
&nbsp;     * Unit tests the {@code In} data type.
&nbsp;     *
&nbsp;     * @param args the command-line arguments
&nbsp;     */
&nbsp;    public static void main(String[] args) {
&nbsp;        In in;
<b class="nc">&nbsp;        String urlName = &quot;https://introcs.cs.princeton.edu/java/stdlib/InTest.txt&quot;;</b>
&nbsp;
&nbsp;        // read from a URL
<b class="nc">&nbsp;        System.out.println(&quot;readAll() from URL &quot; + urlName);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(urlName);</b>
<b class="nc">&nbsp;            System.out.println(in.readAll());</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;        // read one line at a time from URL
<b class="nc">&nbsp;        System.out.println(&quot;readLine() from URL &quot; + urlName);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(urlName);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readLine();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;        // read one string at a time from URL
<b class="nc">&nbsp;        System.out.println(&quot;readString() from URL &quot; + urlName);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(urlName);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readString();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;
&nbsp;        // read one line at a time from file in current directory
<b class="nc">&nbsp;        System.out.println(&quot;readLine() from current directory&quot;);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(&quot;./InTest.txt&quot;);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readLine();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;
&nbsp;        // read one line at a time from file using relative path
<b class="nc">&nbsp;        System.out.println(&quot;readLine() from relative path&quot;);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(&quot;../stdlib/InTest.txt&quot;);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readLine();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;        // read one char at a time
<b class="nc">&nbsp;        System.out.println(&quot;readChar() from file&quot;);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(&quot;InTest.txt&quot;);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                char c = in.readChar();</b>
<b class="nc">&nbsp;                System.out.print(c);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;        // read one line at a time from absolute OS X / Linux path
<b class="nc">&nbsp;        System.out.println(&quot;readLine() from absolute OS X / Linux path&quot;);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(&quot;/n/fs/introcs/www/java/stdlib/InTest.txt&quot;);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readLine();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
&nbsp;
&nbsp;        // read one line at a time from absolute Windows path
<b class="nc">&nbsp;        System.out.println(&quot;readLine() from absolute Windows path&quot;);</b>
<b class="nc">&nbsp;        System.out.println(&quot;---------------------------------------------------------------------------&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            in = new In(&quot;G:\\www\\introcs\\stdlib\\InTest.txt&quot;);</b>
<b class="nc">&nbsp;            while (!in.isEmpty()) {</b>
<b class="nc">&nbsp;                String s = in.readLine();</b>
<b class="nc">&nbsp;                System.out.println(s);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            System.out.println();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.out.println(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println();</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;}
&nbsp;
&nbsp;/******************************************************************************
&nbsp; *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
&nbsp; *
&nbsp; *  This file is part of algs4.jar, which accompanies the textbook
&nbsp; *
&nbsp; *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
&nbsp; *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
&nbsp; *      http://algs4.cs.princeton.edu
&nbsp; *
&nbsp; *
&nbsp; *  algs4.jar is free software: you can redistribute it and/or modify
&nbsp; *  it under the terms of the GNU General Public License as published by
&nbsp; *  the Free Software Foundation, either version 3 of the License, or
&nbsp; *  (at your option) any later version.
&nbsp; *
&nbsp; *  algs4.jar is distributed in the hope that it will be useful,
&nbsp; *  but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
&nbsp; *  GNU General Public License for more details.
&nbsp; *
&nbsp; *  You should have received a copy of the GNU General Public License
&nbsp; *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
&nbsp; ******************************************************************************/
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-17 00:14</div>
</div>
</body>
</html>
